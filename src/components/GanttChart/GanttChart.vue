<template>
	<div class="farm-gantt-chart" :style="componentStyle">
		<div class="farm-gantt-chart__header">
			<div class="farm-gantt-chart__row-label-space"/>
			<div class="farm-gantt-chart__timeline" :style="timelineGridStyle">
				<div
					v-for="(month, index) in monthColumns"
					:key="index"
					class="farm-gantt-chart__month-header"
					:class="{ 'farm-gantt-chart__month-header--current': month.isCurrentMonth }"
				>
					<farm-typography
						size="md"
						:weight="500"
						:color="month.isCurrentMonth ? 'primary' : 'black'"
						:color-variation="month.isCurrentMonth ? '' : '50'"
						class="mb-0"
					>
						{{ month.label }}
					</farm-typography>
				</div>
			</div>
		</div>

		<!-- Gantt Chart Content --> 
		<div class="farm-gantt-chart__content">
			<div
				v-for="(group, groupIndex) in data.groups"
				:key="'group-' + groupIndex"
				class="farm-gantt-chart__group"
			>
				<!-- Group label -->
				<div class="farm-gantt-chart__group-label">
					<farm-typography :weight="500">
						{{ group.title }}
					</farm-typography>
				</div>

				<!-- Group timeline with grid and bars -->
				<div class="farm-gantt-chart__group-timeline" :style="timelineGridStyle">
					<!-- Bars positioned using CSS Grid -->
					<div
						v-for="(bar, barIndex) in getPositionedBars(group.bars)"
						:key="'bar-' + barIndex"
						class="farm-gantt-chart__bar"
						:style="getBarGridStyle(bar)"
						@click="$emit('bar-click', bar)"
					>
						<farm-typography size="md" :weight="500" color="white" class="mb-0" ellipsis>
							{{ bar.label }}
						</farm-typography>
					</div>
				</div>
			</div>
		</div>

		<!-- Legend -->
		<div class="farm-gantt-chart__legend" v-if="autoGeneratedLegend.length > 0" :style="legendStyle">
			<div class="farm-gantt-chart__legend-title">
				<farm-typography size="md" :weight="700" color="black" color-variation="50">
					Legenda:
				</farm-typography>
			</div>
			<div
				v-for="(item, index) in autoGeneratedLegend"
				:key="'legend-' + index"
				class="farm-gantt-chart__legend-item"
			>
				<div
					class="farm-gantt-chart__legend-color"
					:style="{ backgroundColor: item.color }"
				></div>
				<div class="farm-gantt-chart__legend-label">
					<farm-typography size="md" color="black" color-variation="50">
						{{ item.label }}
					</farm-typography>
				</div>
			</div>
		</div>
	</div>
</template>

<script lang="ts">
import { defineComponent, PropType, computed } from 'vue';
import type { GanttData, GanttBar } from './types';
import { isValid } from 'date-fns';
import {
	getMonthsBetween,
	formatMonth,
	isCurrentMonth,
	getDaysInMonth,
	getColumnForDate
} from './utils/dateUtils';

export default defineComponent({
	name: 'farm-gantt-chart',
	props: {
	
		data: {
			type: Object as PropType<GanttData>,
			required: true,
		},
	},
	emits: ['bar-click'],
	setup(props) {
		// Cálculo automático de datas baseado nas barras
		const autoCalculatedDateRange = computed(() => {
			const allDates: Date[] = [];
			
			props.data.groups.forEach(group => {
				group.bars.forEach(bar => {
					const startDate = bar.start instanceof Date ? bar.start : new Date(bar.start);
					const endDate = bar.end instanceof Date ? bar.end : new Date(bar.end);
					
					if (isValid(startDate)) {
						allDates.push(startDate);
					}
					if (isValid(endDate)) {
						allDates.push(endDate);
					}
				});
			});

			if (allDates.length === 0) {
				// Fallback para caso não haja barras válidas
				const now = new Date();
				return {
					start: new Date(now.getFullYear(), 0, 1),
					end: new Date(now.getFullYear(), 11, 31)
				};
			}

			const minDate = new Date(Math.min(...allDates.map(d => d.getTime())));
			const maxDate = new Date(Math.max(...allDates.map(d => d.getTime())));

			// Ajustar para início/fim do mês conforme o plano
			minDate.setDate(1); // primeiro dia do mês
			maxDate.setMonth(maxDate.getMonth() + 1, 0); // último dia do mês

			return { start: minDate, end: maxDate };
		});

		// Geração automática da legenda baseada nas cores e labels únicos
		const autoGeneratedLegend = computed(() => {
			const uniqueItems = new Map<string, { label: string; color: string }>();

			props.data.groups.forEach(group => {
				group.bars.forEach(bar => {
					const key = `${bar.color}-${bar.label}`;
					if (!uniqueItems.has(key)) {
						uniqueItems.set(key, {
							label: bar.label,
							color: bar.color
						});
					}
				});
			});

			return Array.from(uniqueItems.values());
		});

		// Generate month columns using calculated date range
		const monthColumns = computed(() => {
			const { start, end } = autoCalculatedDateRange.value;
			const months = getMonthsBetween(start, end);
			return months.map(month => ({
				date: month,
				label: formatMonth(month),
				isCurrentMonth: isCurrentMonth(month),
			}));
		});

		// CSS Grid template for timeline
		const timelineGridStyle = computed(() => ({
			gridTemplateColumns: `repeat(${monthColumns.value.length}, 80px)`,
		}));

		// Get today's column position
		const todayColumn = computed(() => {
			const today = new Date();
			const { start } = autoCalculatedDateRange.value;
			const column = getColumnForDate(today, start);
			// Only show if today is within the chart range
			return column >= 0 && column < monthColumns.value.length ? column : -1;
		});

		/**
		 * Normalize and validate bar dates
		 */
		const normalizeBarDates = (bar: GanttBar) => {
			const startDate = bar.start instanceof Date ? bar.start : new Date(bar.start);
			let endDate = bar.end instanceof Date ? bar.end : new Date(bar.end);

			// Validate dates
			if (!isValid(startDate) || !isValid(endDate)) {
				return null;
			}

			// Ensure end is not before start
			if (endDate < startDate) {
				endDate = new Date(startDate.getTime());
			}

			return { startDate, endDate };
		};

		/**
		 * Calculate month fractions for positioning within a single month
		 */
		const calculateSingleMonthPositioning = (startDate: Date, endDate: Date) => {
			const startDay = startDate.getDate();
			const startMonth = startDate.getMonth();
			const startYear = startDate.getFullYear();
			const endDay = endDate.getDate();
			const endMonth = endDate.getMonth();
			const endYear = endDate.getFullYear();

			const daysInMonth = getDaysInMonth(startYear, startMonth);

			// Calculate start position as fraction of month
			const startFraction = (startDay - 1) / daysInMonth;

			// Calculate end position - if bar ends in same month, use actual end day
			// otherwise, use end of start month
			const effectiveEndDay = (startYear === endYear && startMonth === endMonth)
				? endDay
				: daysInMonth;
			const endFraction = effectiveEndDay / daysInMonth;

			return {
				marginLeft: `calc(${startFraction * 100}%)`,
				width: `calc(${(endFraction - startFraction) * 100}%)`
			};
		};

		/**
		 * Calculate positioning for bars spanning multiple months
		 */
		const calculateMultiMonthPositioning = (
			startDate: Date,
			endDate: Date,
			visualMonthsSpanned: number,
			gridColumnsSpanned: number
		) => {
			const startDay = startDate.getDate();
			const endDay = endDate.getDate();
			const startMonth = startDate.getMonth();
			const startYear = startDate.getFullYear();
			const endMonth = endDate.getMonth();
			const endYear = endDate.getFullYear();

			const daysInStartMonth = getDaysInMonth(startYear, startMonth);
			const daysInEndMonth = getDaysInMonth(endYear, endMonth);

			// Calculate fractions for start month, full intermediate months, and end month
			const fractionBeforeBar = (startDay - 1) / daysInStartMonth;
			const fractionInStartMonth = (daysInStartMonth - (startDay - 1)) / daysInStartMonth;
			const fractionInEndMonth = endDay / daysInEndMonth;
			const fullIntermediateMonths = Math.max(0, visualMonthsSpanned - 2);

			// Avoid division by zero
			if (gridColumnsSpanned <= 0) {
				return { marginLeft: '0%', width: '100%' };
			}

			// Calculate total bar coverage across all months
			const totalBarCoverage = fractionInStartMonth + fullIntermediateMonths + fractionInEndMonth;

			return {
				marginLeft: `calc((${fractionBeforeBar} / ${gridColumnsSpanned}) * 100%)`,
				width: `calc((${totalBarCoverage} / ${gridColumnsSpanned}) * 100%)`
			};
		};

		/**
		 * Get CSS Grid style for a bar - refactored for clarity
		 */
		const getBarGridStyle = (bar: GanttBar) => {
			const { start: chartStartDate } = autoCalculatedDateRange.value;

			// Step 1: Normalize and validate dates
			const dates = normalizeBarDates(bar);
			if (!dates) {
				// Return fallback style for invalid dates
				return {
					gridColumn: '1 / 2',
					backgroundColor: bar.color,
					gridRow: `${(bar.rowPosition || 0) + 1}`,
				};
			}

			const { startDate, endDate } = dates;

			// Step 2: Calculate grid column positions
			const startColumnIndex = getColumnForDate(startDate, chartStartDate);
			const endColumnIndex = getColumnForDate(endDate, chartStartDate);
			
			const gridColumnStart = Math.max(1, startColumnIndex + 1);
			const gridColumnEnd = Math.min(monthColumns.value.length + 1, endColumnIndex + 2);
			const gridColumnsSpanned = gridColumnEnd - gridColumnStart;

			// Step 3: Calculate visual month span for proportional positioning
			const visualStartCol = getColumnForDate(startDate, chartStartDate);
			const visualEndCol = getColumnForDate(endDate, chartStartDate);
			const visualMonthsSpanned = visualEndCol - visualStartCol + 1;

			// Step 4: Calculate proportional positioning based on month span
			let positioning;
			if (visualMonthsSpanned === 1) {
				// Bar fits within a single month - calculate precise positioning within that month
				positioning = calculateSingleMonthPositioning(startDate, endDate);
			} else {
				// Bar spans multiple months - calculate proportional positioning across months
				positioning = calculateMultiMonthPositioning(
					startDate,
					endDate,
					visualMonthsSpanned,
					gridColumnsSpanned
				);
			}

			return {
				'grid-column-start': gridColumnStart,
				'grid-column-end': gridColumnEnd,
				'background-color': bar.color,
				'grid-row': `${(bar.rowPosition || 0) + 1}`,
				'margin-left': positioning.marginLeft,
				'width': positioning.width,
			};
		};

		// Calculate vertical positions for bars to avoid overlapping
		const getPositionedBars = (bars: GanttBar[]) => {
			if (!bars || bars.length === 0) return [];

			// Clone the bars to avoid modifying the original
			const positionedBars = JSON.parse(JSON.stringify(bars));

			// Sort bars by start date
			positionedBars.sort((a: GanttBar, b: GanttBar) => {
				return new Date(a.start).getTime() - new Date(b.start).getTime();
			});

			// Track occupied rows
			const occupiedUntil: number[] = [];

			// Assign row positions
			positionedBars.forEach((bar: GanttBar) => {
				// Ensure we have valid dates
				const startDate = bar.start instanceof Date ? bar.start : new Date(bar.start);
				const endDate = bar.end instanceof Date ? bar.end : new Date(bar.end);

				// Validate dates and use fallback if invalid
				const barStart = isValid(startDate) ? startDate.getTime() : Date.now();
				const barEnd = isValid(endDate) ? endDate.getTime() : Date.now() + 86400000; // +1 day fallback

				// Find the first available row
				let rowPosition = 0;
				while (occupiedUntil[rowPosition] && occupiedUntil[rowPosition] > barStart) {
					rowPosition++;
				}

				// Assign the row position to the bar
				bar.rowPosition = rowPosition;

				// Mark this row as occupied until the bar ends
				occupiedUntil[rowPosition] = barEnd;
			});

			return positionedBars;
		};

		// Calculate content height based on groups
		const contentHeight = computed(() => {
			let totalHeight = 0;
			props.data.groups.forEach(group => {
				const positionedBars = getPositionedBars(group.bars);
				const maxRows = Math.max(
					1,
					...positionedBars.map(bar => (bar.rowPosition || 0) + 1)
				);
				const groupHeight = Math.max(60, maxRows * 35 + 10); // 35px per row + padding
				totalHeight += groupHeight + 20; // 20px margin between groups
			});
			return totalHeight;
		});

		// CSS variables for the component
		const componentStyle = computed(() => ({
			'--gantt-content-height': `${contentHeight.value}px`,
		}));

		// Calculate legend width to match the complete timeline width
		const legendStyle = computed(() => {
			const timelineWidth = monthColumns.value.length * 80; // 80px per month column
			const totalWidth = 120 + timelineWidth; // 120px label space + timeline width
			return {
				width: `${totalWidth}px`,
			};
		});

		return {
			monthColumns,
			timelineGridStyle,
			todayColumn,
			autoGeneratedLegend,
			legendStyle,
			getBarGridStyle,
			getPositionedBars,
			componentStyle,
		};
	},
});
</script>

<style lang="scss" scoped>
@import './GanttChart';
</style>
